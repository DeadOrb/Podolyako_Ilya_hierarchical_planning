# Podolyako_Ilya_hierarchical_planning

Репозиторий для проекта 2 курса Факультета компьютерных наук Высшей школы экономики

В данный момент в папке malte-pyperplan лежит планировщик пайперплен. В папке Java HEART лежит планировщик на Java, на котором реализованы алгоритмы HEART, POP, HiPOP, HTN, под авторством Antoine Grea(создатель алгоритма HEART).В папке Control point 1 и Control point 2 лежат материалы за каждую точку(отчёты и всё остальное).


# Запуск и работа с планнировщиком

Для работы с проектом требуется python 3.7.1(иначе совместимость не гарантируется). Всё дополнительное лежит в requirement.txt(на данный момент он не требуется). Функция main определена в файле main в корне проекта. Для запуска треубется ввести абсолютные пути до домена и таски в параметрах(обязательно в таком порядке!!!). После этого проект напечатает вам после граундинга вашу задачу.

# Язык описанния в данном планировщике:
В данном планиировщике используется pddl (настолько, на сколько он требуется, поэтому возможно не всё определно), ниже приводится более детальное описание синтаксических конструкций в данном проекте, для того, чтобы не было сложностей с пониманием используемого формального языка:

Есть два вида файлов: домен и таска. В первом файле присутствует описание физического мира, во втором описание задачи принадлежащей какому либо домену.

Рассмотрим синтаксический вид домена:

>Формально домен задачи выглядит так:

>\<domain\> = (

>define

>(domain name)

>(:requirements \<require-flag\>)

>(:types \<types-definition\>)

>(:constants \<constants-definition\>)
  
>(:predicates \<atomic-formula-prototype\>)

>(\<action-def\>)

>(\<methods-def\>)

>)

Теперь разберём каждое поле отдельно:

define - начало определния домена задачи, после него идёт определение всех остальных частей.

domain name - имя домена, может быть задан любой строкой, слово domain не входит в имя.

\<require-flag\> - требования флаги к домену, к примеру :typing - типизация или :hierarchical - иерархия методов.

\<types-definition\> - определения типов в задаче, работает только если есть флаг :typing в требованиях. Задаётся одним словом(в данный момент).

\<constants-definition\> - такое же описание, что и у поля типов.

<atomic-formula-prototype\> - имя и список предикатов использующихся в домене, для описания состояний мира:

> \<atomic-formula-prototype\>	=	(\<predicate_name\> (\<params-definition\>))

Сами поля params имеют следующий вид:

>(\<params-definition\>) = 	<param_name> - <type_name>
Где первое это имя параметра, а второе тип(иногда можно проигнорировать тип, к примеру мы можем задать предикат пустоты руки, он определён когда рука ничего не держит, и он not когда рука чем-то занята)
Перед переменными объектами всегда стоит вопрос, к примеру ?x.

\<action-def\> - действие. Это доступные для нас действия с окружающим миром изменяющие состояния мира. В свою очередь действия определены так:
>\<action-def\>=(

>:action	\<name\>

>(:parameters (\<params-definition\>))

>(:precondition (\<goal-definition\>))

>(:effect (\<effect-definition\>))

>)
По аналогии первое поле это имя, второе поле это параметры. Третье поле это предусловие, составленно из предикатов, описывающих состояние мира. Последнее поле это эффект, также описывающее состояние мира после применения действия.

(\<methods-def\>) - метод, это иерархическое действие, которое задаётся в виде субцелей и порядков. Такие действия в нашей задаче не генерируются, а считаются уже подающимися на вход. Определим это поле:

> \<methods-def\> = (

>:method name

>(:parameters (\<params-definition\>))

>(:subgoals (\<subgoals-definition\>))

>(:ordering (\<ordering-definition\>))

Первое поле имя, второе поле параметры. Тут всё аналогично предыдущим определениям. Теперь рассмотрим поле subgoals. В это поле написаны подцели нашего метода, чтобы его собрать. Подцели задаются одним квантором вначале(and к примеру), и подцелями. Каждая подцель представлена названием и неким действием, которое приведёт к желаемому действию. 

Рассмотрим поле ordering. В этом поле заданы порядки задачи. Мы получаем выражения (a < b), где a и b наши цели из подцелей, таким образом мы говорим порядок действий в нашей задаче.












